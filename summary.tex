\section{Zusammenfassung}
Die meisten Entwickler sträuben sich davor im Detail mit asynchroner Verarbeitung zu befassen. Jedoch kommt man in Javascript nicht drumherum, sich damit auseinanderzusetzen. Entweder man liest sich kurz in das Grundkonzept eines asynchronen Verarbeitungskonzeptes ein, und hofft, dass der Code das \glqq richtige tut\grqq{}. Oder man lernt die Anatomie eines Ansatzes im Detail kennen und steigt mit dem entwickeln später ein. Am Ende muss abgewogen werden, ob man am Ende bei der Fehlersuche oder beim Erlernen des Ansatzes Zeit in Anspruch nehmen möchte. Sich mit dieser Arbeit im Vorfeld beschäftigt zu haben, erspart dem Entwickler beim Anwenden dieser Ansätze Zeit und Nerven. Insbesondere kann bei einem Fehlerauftritt entsprechende Vermutungen am Fehler des Codes gestellt werden. Asynchrone Programmierung ist nicht leicht zu verstehen. Javascript ist eine Single-Threaded Skriptsprache und sollte immer als solche gesehen werden. Wenn eine Aktion asynchron stattfindet wird kein zweiter Thread gestartet. Im Gegenteil, die Aktion wird erst verarbeitet wenn, 

\begin{description}
\item entweder erfolgreich oder fehlerhaft vollendet ist,
\item die Event-Loop die Aktion registriert hat,
\item und der aktuelle Call stack leer ist.
\end{description}

\noindent
Erst dann schiebt die Event-Loop die Funktion die diese Aktion verarbeitet in den Call stack rein. So handhabt Javascripts Interpreter asynchrone Operationen. Um diese asynchrone Operationen zu verarbeiten bietet Javascript, die in dieser Arbeit gegenübergestellten Methodiken zur Verfügung. Callbacks gründeten den Anfang der asynchronen Verarbeitung. Callbacks sind selbst heutzutage ein durchaus valider Ansatz zur asynchronen Verarbeitung. Insbesondere in sofern, da dieser Ansatz das Kernkonzept der funktionalen Programmierung bildet. Javascript ist multiparadigmatisch. Promises werden syntaktisch \glqq sauberer\grqq{} verarbeitet. Demzufolge wurde, ähnlich wie in RxJS heute, die Nutzung von Promises durch externe Bibliotheken herangezogen. Als Promises nativ nutzbar waren, kam bereits kurze Zeit später async await raus. Async await bedienen sich die Nutzung von Promises in einer neuen Art und Weise. Promises konnten von nun an ohne Verschachtelung genutzt werden. Async await sollte jedoch nur eingesetzt werden, wenn man das Prinzip der Promises versteht. Ansonsten lässt die synchron dargestellte Code Struktur andeuten, dass await den synchronen Fluss stoppt. Observables bieten ein komplett neuen Ansatz der asynchronen Verarbeitung. In einem Anwendungsfall an dem eine Monitoring Applikation die aktuell angemeldeten Nutzer einer anderen Applikation verfolgt, würde in einer klassischen Implementierung beispielsweise alle 10 Sekunden ein Aufruf am Endpunkt gemacht werden müssen. Eine elegantere Variante wäre ein Observable mit einem Endpunkt zu verbinden und Änderungen der Nutzeranzahl führen zu einem neuen Wert an einem Observable. Somit ist es unter Anderem Möglich Daten in Echtzeit zu verarbeiten. Observables sind ein neuer Ansatz eines Push-Systems.
