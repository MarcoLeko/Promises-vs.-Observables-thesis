\section{Zusammenfassung}

Kaum ein Entwickler befasst sich anfänglich genauestens mit asynchroner Verarbeitung in Javascript. Jedenfalls nicht, bis spätestens ein Fehler in der Implementation auftritt und man sich mit der Ursache des Problems auseinandersetzen muss. Am Ende muss abgewogen werden, ob man bei der Fehlersuche oder beim Erlernen des Ansatzes Zeit in Anspruch nehmen möchte. Sich mit dieser Arbeit beschäftigt zu haben, erspart dem Entwickler beim Anwenden dieser Methoden Zeit und Nerven, da im Vorfeld berüchtigte Fehler vermieden werden. Und wenn doch, können bei einem Fehlerauftritt entsprechende Vermutungen an der Ursache gestellt werden. Asynchrone Programmierung ist nicht leicht zu verstehen. Javascript ist eine Single-Threaded Skriptsprache und sollte immer als solche gesehen werden. Aber all die anderen Dinge, die der Browser nebenher ausführt wie z.B. Netzwerkanfragen, Rendering oder Event-Triggers finden in einem anderen Thread statt. Diese asynchronen Aktionen werden vom Call stack erst dann verarbeitet wenn, 

\begin{itemize}
\item sie entweder erfolgreich oder fehlerhaft fertiggestellt ist,
\item die Event-Loop die Aktion registriert hat
\item und der aktuelle Call stack leer ist.
\end{itemize}

\noindent
Erst dann schiebt die Event-Loop die Funktion, die diese Aktion verarbeitet in den Aufrufstapel rein. So handhabt Javascripts Interpreter asynchrone Operationen. Um diese asynchrone Operationen zu verarbeiten bietet Javascript, die in dieser Arbeit gegenübergestellten Ansätze zur Verfügung. Callbacks gründeten den Anfang der asynchronen Verarbeitung. Callbacks sind selbst heutzutage ein durchaus valider Ansatz zur asynchronen Verarbeitung. Insbesondere, da dieser Ansatz das Kernkonzept der funktionalen Programmierung bildet. Promises werden syntaktisch \glqq sauberer\grqq{} verarbeitet. Demzufolge wurde, ähnlich wie in RxJS heute, die Nutzung von Promises durch externe Bibliotheken herangezogen. Als Promises nativ nutzbar waren, kam bereits kurze Zeit später Async Await raus. Async await arbeitet intern mit Promises in einer neuen Art und Weise. Promises konnten von nun an ohne Einrückung und Verarbeitungsmethoden genutzt werden. Async await sollte jedoch nur eingesetzt werden, wenn man das Prinzip der Promises versteht. Ansonsten lässt die synchron dargestellte Code- Struktur andeuten, dass await den synchronen Fluss stoppt. Observables bieten eine komplett neue Vorgehensweise Daten asynchron zu verarbeiten. Sie werden unter einem Push-System eingeordnet, dass mehrere Werte mit der Zeit ausgeben kann. Mit Observables ist es möglich Daten in Echtzeit zu verarbeiten. In einem Anwendungsfall, an dem eine Monitoring Applikation die aktuell angemeldeten Nutzer einer anderen Applikation verfolgt, würde in einer klassischen Implementierung beispielsweise alle zehn Sekunden einen Aufruf am Endpunkt gemacht werden müssen. Eine elegantere Variante wäre ein Observable mit einem Endpunkt zu verbinden und die Änderungen der Nutzeranzahl reaktiv zu verarbeiten.
