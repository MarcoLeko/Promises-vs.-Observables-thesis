\section{Zusammenfassung}

Kaum ein Entwickler befasst sich anfänglich genauestens mit asynchroner Verarbeitung in Javascript. Jedenfalls nicht spätestens ein Fehler in der Implementation auftritt und man sich mit der Ursache des Problems auseinandersetzen muss. Am Ende muss abgewogen werden, ob man bei der Fehlersuche oder beim Erlernen des Ansatzes Zeit in Anspruch nehmen möchte. Sich mit dieser Arbeit im Vorfeld beschäftigt zu haben, erspart dem Entwickler beim Anwenden dieser Methoden Zeit und Nerven. Insbesondere kann bei einem Fehlerauftritt entsprechende Vermutungen am Fehler des Codes gestellt werden. Asynchrone Programmierung ist nicht leicht zu verstehen. Javascript ist eine Single-Threaded Skriptsprache und sollte immer als solche gesehen werden. Aber all die anderen Dinge, die der Browser nebenher ausführt wie z.B. Übertragung Daten bei einer Endpunkt Anfrage, Rendering oder Event-Triggers finden in einem anderen Thread statt. Diese asynchronen Aktionen werden vom Call stack erst dann verarbeitet wenn, 

\begin{description}
\item sie entweder erfolgreich oder fehlerhaft fertiggestellt ist,
\item die Event-Loop die Aktion registriert hat
\item und der aktuelle Call stack leer ist.
\end{description}

\noindent
Erst dann schiebt die Event-Loop die Funktion, die diese Aktion verarbeitet in den Aufrufstapel rein. So handhabt Javascripts Interpreter asynchrone Operationen. Um diese asynchrone Operationen zu verarbeiten bietet Javascript, die in dieser Arbeit gegenübergestellten Ansätze zur Verfügung. Callbacks gründeten den Anfang der asynchronen Verarbeitung. Callbacks sind selbst heutzutage ein durchaus valider Ansatz zur asynchronen Verarbeitung. Insbesondere, da dieser Ansatz das Kernkonzept der funktionalen Programmierung bildet. Promises werden syntaktisch \glqq sauberer\grqq{} verarbeitet. Demzufolge wurde, ähnlich wie in RxJS heute, die Nutzung von Promises durch externe Bibliotheken herangezogen. Als Promises nativ nutzbar waren, kam bereits kurze Zeit später Async Await raus. Async await bedienen sich die Nutzung von Promises in einer neuen Art und Weise. Promises konnten von nun an ohne Verschachtelung genutzt werden. Async await sollte jedoch nur eingesetzt werden, wenn man das Prinzip der Promises versteht. Ansonsten lässt die synchron dargestellte Code- Struktur andeuten, dass await den synchronen Fluss stoppt. Observables bieten ein komplett neuen Ansatz der asynchronen Verarbeitung. Sie werden unter einem einem Push-System eingeordnet, dass mehrere Werte mit der Zeit ausgeben kann. Mit Observables ist es Möglich Daten in Echtzeit zu verarbeiten. In einem Anwendungsfall, an dem eine Monitoring Applikation die aktuell angemeldeten Nutzer einer anderen Applikation verfolgt, würde in einer klassischen Implementierung beispielsweise alle 10 Sekunden einen Aufruf am Endpunkt gemacht werden müssen. Eine elegantere Variante wäre ein Observable mit einem Endpunkt zu verbinden und Änderungen der Nutzeranzahl reaktiv  zu verarbeiten.
