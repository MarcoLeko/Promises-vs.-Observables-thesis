\section{Async await}
Wenn es um das Verarbeiten von asynchronen Operationen geht, sind Promises ein erheblicher Fortschritt im Vergleich zum Callback Prinzip. Jedoch wurde ein grundlegendes Problem noch nicht gelöst: Mit der Nutzung von Promises ist der Code immer noch geschachtelt. Ziel ist es, asynchrone Aktionen so abzubilden, als ob diese synchron ausgeführt werden. Die webpack.config.js sollte als Eingangspunkt die ../async-await/introduction.ts Datei annehmen.

\begin{figure}[H]
\begin{lstlisting}[basicstyle=\small]
const hello: Promise<string> = new Promise(resolve =>
    setTimeout(() => resolve('Hello'), 1000)
);
const world: string = 'World';

hello
    .then(value => console.log(value, world));
\end{lstlisting}
\caption{Umsetzung mit einem Promise.}
\label{Promise-comparison-async-await}
\end{figure}

\noindent
Da Promises selbst Rückruffunktionen nutzen, wird einem schnell klar, dass hier eine asynchrone Aktion stattfindet. Mit der Erscheinung von Ecmascript 2017 gibt es nun die Möglichkeit asynchron operierenden Code lesbarer darzustellen. Dies wird mit dem \textbf{async await} Konstrukt bewerkstelligt. 

\subsection{Funktionsweise}

Async/Await sind Schlüsselwörter in Javascript, welche die asynchrone Programmierung wesentlich vereinfachen. Wenn vor einer Funktion das Schlüsselwort \textbf{async} steht bedeutet dies nur eins: Die Funktion gibt immer ein Promise zurück.

\begin{figure}[H]
\begin{lstlisting}[basicstyle=\small]
function hello() {
    return 'world';
}
\end{lstlisting}
\caption{Funktion gibt explizit und implizit ein string zurück.}
\end{figure}

\begin{figure}[H]
\begin{lstlisting}[basicstyle=\small]
async function hello() {
    return 'world';
}
\end{lstlisting}
\caption{Funktion gibt explizit ein string und implizit ein Promise\textless string\textgreater zurück.}
\end{figure}

\noindent
Der async Ausdruck an einer Funktion wandelt den Rückgabetyp T in ein Promise\textless T\textgreater um. Um explizit und implizit ein Promise\textless string\textgreater zu verwenden, könnte man beispielsweise ein Promise.resolve('world') ausliefern. Eine async Funktion kann zudem einen \textbf{await} Ausdruck enthalten. Mit await wird die Ausführung der Funktion pausiert bis das verwendete Promise eingetroffen ist. Daraufhin wird die Ausführung der Funktion mit dem zurückgegeben Wert des Promise fortgesetzt. Ein await ist nur innerhalb einer async Funktion valide einsetzbar. Das obere Beispiel (Abb. \ref{Promise-comparison-async-await}) würde mit async await so aussehen:

\begin{figure}[H]
\begin{lstlisting}[basicstyle=\small]
async function hello2() {
    const value = await hello;
    console.log(value, world);
}

hello2();
\end{lstlisting}
\caption{Umsetzung mit async await.}
\end{figure}

\noindent
Wie man sehen kann wird an dem await Ausdruck eine Konstante gebildet um das Ergebnis weiterzunutzen. Für den Promise Wert werden keinerlei Verarbeitungsmethoden mehr benötigt. Der await Ausdruck greift direkt auf den Wert zu. Obwohl es für gewöhnlich so beschrieben wird, dass await die Exekution der Funktion pausiert, sollte man daraus nicht schlussfolgern, dass die Funktion synchron operiert. In Wahrheit, await bricht den synchronen Fluss und jede nachfolgende Anweisung innerhalb der Funktion operiert asynchron. Das heißt ein await Ausdruck blockiert nicht den synchronen Fluss von Javascripts Interpreter. Sie lässt das Ausführungsmodell asynchron agieren.

\begin{figure}[H]
\begin{lstlisting}[basicstyle=\small]
async function fn() {
    const result = await Promise.resolve('foo');
    console.log(result);
}

fn();
console.log('bar');
// bar
// foo
\end{lstlisting}
\caption{In diesem Fall wird bar vor foo angezeigt.}
\end{figure}

\noindent
Await stoppt die weitere Ausführung des Funktionsrumpfes bis der Promise in den settled Zustand angelangt ist. Aber diese Auflösung wird erst, wenn der Call stack vollständig verarbeitet wurde. Dieses Konzept wird auch \textbf{run to completion} genannt. Die Stärke von async await ist die Syntax. Eine Applikation, die von asynchronen Operationen getrieben ist, kann nun in der Code Struktur synchron abgebildet werden. 

\subsection{Error Handling}
Wenn ein Promise eintrifft, liefert der await Ausdruck das Ergebnis zurück. Hingegen wird bei einem Promise Fehlschlag ein Error geworfen, ähnlich wie bei einem \textbf{throw} Ausdruck. Wie in Java oder Swift gibt es auch in Javascript ein \textbf{try-catch} Block. Wenn ein Promise fehlschlägt, kann daraufhin mit dem catch Block der Fehler gefangen werden. Code-technisch würde dies so aussehen: 

\begin{figure}[H]
\begin{lstlisting}[basicstyle=\small]
async function helloWorldFailure() {
    try {
        const failure = await Promise.reject('Error');
        console.log(failure, world);
    } catch (error) {
        console.log(error, world + 'should be: Hello', world);
    }
}

helloWorldFailure();
\end{lstlisting}
\caption{Es wird niemals console.log(failure, world) ausgeführt, da innerhalb des await Konstrukts eine Exception geworfen wird.}
\end{figure}

\noindent
Um sich ein besseres Bild von der Nützlichkeit von async await zu machen, werden die Kapitelaufrufe in der Promise Sektion mit async await nachgestellt. Vor dem Ausführen des Beispiels sollte die ../async-await/stories-usage.ts als Eingangsdatei definiert werden.


\begin{figure}[H]
\begin{lstlisting}[basicstyle=\small]
const story = new Story();

async function getFirstSections() {
    try {
        for (const n of [1, 2, 3]) {
            story.spawn(await story.getChapter(n));
        }
    } finally {
        story.displayFinished();
    }
}
\end{lstlisting}
\caption{Die Methode verhält sich genau so wie in Abb. \ref{Promises-sequential-calls}}
\end{figure}

\noindent
Ohne jeglicher Verkettung wird mit dem await Konstrukt auf die Promise Auflösung gewartet und der entstandene Wert als Parameter in der Methode spawn() übergeben. Daraufhin wird weiter in der Schleife iteriert. Zudem bietet der try-catch Block auch finally an. Ähnlich wie bei der Promise-Prototyp Methode wird unabhängig vom Ausgang des try-catch Blocks in dem finally-Block vorrangeschreitet.

\subsection{Einsetzen wenn sinnvoll}

Beim Einsetzen von async await muss sich vor Augen geführt werden, wann ein Einsatz als solches Sinn ergibt. Kommt man wieder zum Anwendungsfall, man möchte die ersten drei Kapitel parallel in die DOM laden, würde der Code hierfür so aussehen:

\begin{figure}[H]
\begin{lstlisting}[basicstyle=\small]
async function getFirstSectionsInParallel() {
    try {
        const promises = [];

        [1, 2, 3].forEach(n => promises.push(story.getChapter(n)));

        story.spawn(await Promise.all(promises));
    } finally {
        story.displayFinished();
    }
}

getFirstSectionsInParallel();
\end{lstlisting}
\caption{Async await nutzt intern Promise Objekte.}
\end{figure}

\noindent
Wie man sehen kann gibt es keinen großen Mehrwert innerhalb der async await Exekution im Vergleich zur Abbildung \ref{Promise-all-example}. Beim übergeben der Promises in einem Array sind alle im pending Zustand. Erst mit await Promise.all(iterable) wird parallel auf die Auflösung der Promises gewartet. Die Stärke von async await kommt erst dann zur Geltung, wenn mehrere asynchrone Operationen sequentiell ausgeführt werden müssen. Als Faustregel kann festgelegt werden, dass async Funktionen ein Promise-Objekt zurückgeben. Selbst wenn explizit ein Typ angegeben wird, stellt async sicher, dass dieser Typ in ein Promise ist. Ein await Ausdruck pausiert die Ausführung einer asynchronen Funktion, bis die blockierende Aktion eingetroffen ist. Dabei können mehrere awaits innerhalb einer async Funktion definiert werden. Um Fehlschläge zu fangen sollte Javascripts try-catch Block angewendet werden. Es sollte unterschieden werden, ob der Code sequentiell oder parallel ausgeführt werden soll. Wenn asynchrone  Aktionen parallel voneinander ausgeführt werden sollen, kann man auf die Nutzung von async await verzichten.

\subsection{Fazit}

Mit dem Ansatz der Callbacks war es in Javascript erstmals Möglich asynchrone Operationen sequentiell zu verarbeiten. Callbacks sind leicht zu verstehen, jedoch werden sie ineinandergeschachtelt schnell chaotisch und schwer nachzuvollziehen. Entwickler neigten dazu Libraries für asynchrone Verarbeitung zu nutzen wie:

\begin{description}
\item Q
\item when
\item WinJS
\item RSVP.js
\end{description}

\noindent
Durch diese externe Libraries war es Möglich Promises in Javascript zu nutzen. All diese Libraries teilen die gleiche Anatomie eines Promises und verhalten sich nach dem Standard \textbf{Promises/A+}\cite{promises-a+}. Promises wurden mit der Zeit immer beliebter. Sogar so beliebt, dass sie seid der Ecmascript-2015 Version rein nativ nutzbar sind. Mit der Einführung von async await war es sogar erstmals Möglich asynchron operierenden Code übersichtlich abzubilden. Ganz ohne Verschachtelung wurde blockierender Code aufgelöst und in der nächsten Anweisung vorrangeschreitet. All diese Ansätze haben eines gemeinsam: Beim Aufruf werden sie nur einmal verarbeitet. Wenn man mithilfe eines Promise ein Endpunkt-Aufruf macht und dieser eintrifft, ist es irrelevant, ob die API nach zehn Sekunden nicht mehr erreichbar ist. Der Aufruf wurde bereits erfolgreich durchgeführt. Diese Ansätze werden beim Aufruf einmalig für asynchrone Events verarbeitet und liefern nur ein Ergebnis. Mit Observables wird in der nächsten Sektion ein komplett neuer Ansatz gegenübergestellt. Sie haben ein Strom-basiertes Verhalten, dass kein, ein oder multiple Werte mit der Zeit ausgeben. Dieser Ansatz unterscheidet sich grundlegend von den Bisherigen.
