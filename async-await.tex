\section{Async await}
Wenn es um das Verarbeiten von asynchronen Operationen geht, sind Promises ein erheblicher Fortschritt im Vergleich zum Callback Prinzip. Jedoch wurde ein grundlegendes Problem noch nicht gelöst: Asynchroner Code kann immer noch nicht synchron abgebildet werden. Die webpack.config.js sollte als Eingangspunkt die ../async-await/introduction.ts Datei annehmen.

\begin{figure}[H]
\begin{lstlisting}[basicstyle=\small]
const hello: Promise<string> = new Promise(resolve =>
    setTimeout(() => resolve('Hello'), 1000)
);
const world: string = 'World';

hello
    .then(value => console.log(value, world));
\end{lstlisting}
\end{figure}

\noindent
Da Promises selbst Rückruffunktionen nutzen, wird einem schnell klar, dass hier eine asynchrone Aktion stattfindet. Mit der Erscheinung von Ecmascript 2017 gibt es nun die Möglichkeit asynchron geschriebenen Code synchron darzustellen. Dies wird mit dem \textbf{async await} Konstrukt bewerkstelligt. 


\subsection{Funktionsweise}

Bei einer \textbf{async} Funktion handelt es sich um eine Funktion, die dank einer Eventschleife asynchron operiert. In einer Eventschleife werden auf Aktionen gewartet bis diese auftreten. Wenn also vor einer Funktion das Schlüsselwort async steht bedeutet dies nur eins: Die Funktion gibt immer ein Promise zurück.

\begin{figure}[H]
\begin{lstlisting}[basicstyle=\small]
function hello() {
    return 'world';
}
\end{lstlisting}
\caption{Funktion gibt explizit und implizit ein string zurück.}
\end{figure}

\begin{figure}[H]
\begin{lstlisting}[basicstyle=\small]
async function hello() {
    return 'world';
}
\end{lstlisting}
\caption{Funktion gibt explizit ein string und implizit ein Promise\textless string\textgreater zurück.}
\end{figure}

\noindent
Der async Ausdruck an einer Funktion wandelt den Rückgabetyp T in ein Promise\textless T\textgreater um. Um explizit und implizit ein Promise\textless string\textgreater zu verwenden, könnte man beispielsweise ein Promise.resolve('world') ausliefern. Eine async Funktion kann zudem einen \textbf{await} Ausdruck enthalten. Mit await wird die Ausführung der Funktion pausiert bis das genutzte Promise eingetroffen ist. Daraufhin wird die Ausführung der Funktion mit dem zurückgegeben Wert des Promise fortgesetzt. Ein await ist nur innerhalb einer async Funktion valide einsetzbar. Der obere Code würde mit async await so aussehen:

\begin{figure}[H]
\begin{lstlisting}[basicstyle=\small]
async function hello2() {
    const value = await hello;
    console.log(value, world);
}

hello2();
\end{lstlisting}
\end{figure}

\noindent
Wie man sehen kann wird an dem await Ausdruck eine Konstante gebildet um das Ergebnis weiterzunutzen. Für den Promise Wert werden keinerlei Verarbeitungsmethode mehr benötigt. Der await Ausdruck greift direkt auf den Wert zu. Die Stärke von async await ist die Syntax. Eine Applikation, die von asynchronen Operationen getrieben ist, kann nun in der Code Struktur synchron abgebildet werden. 

\subsection{Error Handling}
Wenn ein Promise eintrifft, gibt ein await Promise\textless T\textgreater das Ergebnis zurück. Hingegen wird bei einem Promise Fehlschlag ein Error geworfen, ähnlich wie bei einem \textbf{throw} Ausdruck. Wie in Java oder Swift gibt es auch in Javascript ein \textbf{try-catch} Block. Wenn ein Promise fehlschlägt, kann daraufhin mit dem catch Block der Fehler gefangen werden. Code-technisch würde dies so aussehen: 

\begin{figure}[H]
\begin{lstlisting}[basicstyle=\small]
async function helloWorldFailure() {
    try {
        const failure = await Promise.reject('Error');
        console.log(failure, world);
    } catch (error) {
        console.log(error, world + 'should be: Hello', world);
    }
}

helloWorldFailure();
\end{lstlisting}
\caption{Es wird niemals console.log(failure, world) ausgeführt, da innerhalb des await Konstrukts eine Exception geworfen wird.}
\end{figure}

\noindent
Um sich ein besseres Bild von der Nützlichkeit von async await zu machen, werden die Kapitelaufrufe in der Promise Sektion mit async await nachgestellt. Vor dem Ausführen des Beispiels sollte die ../async-await/stories.ts als Eingangsdatei definiert werden.


\begin{figure}[H]
\begin{lstlisting}[basicstyle=\small]
const story = new Story();

async function getFirstSections() {
    try {
        for (const n of [1, 2, 3]) {
            story.spawn(await story.getChapter(n));
        }
    } finally {
        story.displayFinished();
    }
}
\end{lstlisting}
\caption{Die Methode verhält sich genau so wie in Abb. 13}
\end{figure}

\noindent
Ohne jeglicher Verkettung wird mit dem await Konstrukt auf die Promise Auflösung gewartet und der entstandene Wert als Parameter in der Methode spawn() übergeben. Daraufhin wird weiter in der Schleife iteriert. Zudem bietet der try-catch-Block auch finally an. Ähnlich wie bei der Promise-Prototyp Methode wird unabhängig vom Ausgang des try-catch-Blocks in dem finally-Block vorrangeschreitet.

\subsection{Einsetzen wenn sinnvoll}

Beim Einsetzen von async await muss sich vor Augen geführt werden, wann ein Einsatz als solches Sinn ergibt. Kommt man wieder zum Anwendungsfall, man möchte die ersten drei Kapitel parallel in die DOM laden, würde der Code hierfür so aussehen:

\begin{figure}[H]
\begin{lstlisting}[basicstyle=\small]
async function getFirstSectionsInParallel() {
    try {
        const promises = [];

        [1, 2, 3].forEach(n => promises.push(story.getChapter(n)));

        story.spawn(await Promise.all(promises));
    } finally {
        story.displayFinished();
    }
}

getFirstSectionsInParallel();
\end{lstlisting}
\end{figure}

\noindent
Wie man sehen kann gibt es keinen großen Mehrwert innerhalb der async await Exekution im Vergleich zur Abbildung 14. Beim übergeben der Promises in einem Array sind alle im pending Zustand. Erst mit await Promise.all(iterable) wird parallel auf die Auflösung der Promises gewartet. Die Stärke von async await kommt erst dann zur Geltung, wenn mehrere asynchrone Operationen sequentiell ausgeführt werden müssen. Als Faustregel kann festgelegt werden, dass async Funktionen ein Promise-Objekt zurückgeben. Selbst wenn explizit ein Typ angegeben wird, stellt async sicher, dass dieser Typ in ein Promise ist. Ein await Ausdruck pausiert die Ausführung einer asynchronen Funktion, bis die blockierende Aktion eingetroffen ist. Dabei können mehrere awaits innerhalb einer async Funktion definiert werden. Um Fehlschläge zu fangen sollte Javascripts try-catch Block angewendet werden. Es sollte unterschieden werden, ob der Code sequentiell oder parallel ausgeführt werden soll. Wenn asynchrone  Aktionen parallel voneinander ausgeführt werden sollen, kann man auf die Nutzung von async await verzichten.